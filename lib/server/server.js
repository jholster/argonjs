// Generated by CoffeeScript 1.6.3
var Model, Server, SocketServer, cluster, connect, exports, fs, http, https, jsdom, os, path, send, watch,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

os = require('os');

http = require('http');

path = require('path');

send = require('send');

https = require('https');

cluster = require('cluster');

watch = require('chokidar').watch;

jsdom = require('jsdom');

connect = require('connect');

SocketServer = require('./socket');

Model = require('./model');

Server = (function() {
  function Server(app, options) {
    var arg, authenticate, context, i, markup, name, value, _base, _base1, _base2, _base3, _base4, _base5, _base6, _base7, _base8, _i, _j, _len, _ref, _ref1, _ref2, _ref3,
      _this = this;
    this.app = app;
    this.options = options != null ? options : {};
    _ref = process.argv.slice(1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      arg = _ref[_i];
      if (!(__indexOf.call(arg, '=') >= 0)) {
        continue;
      }
      _ref1 = arg.split('='), name = _ref1[0], value = _ref1[1];
      this.options[name] = value;
    }
    if ((_base = this.options).debug == null) {
      _base.debug = (_ref2 = process.platform) === 'darwin' || _ref2 === 'win32';
    }
    if ((_base1 = this.options).project_path == null) {
      _base1.project_path = process.cwd();
    }
    if ((_base2 = this.options).static_dir == null) {
      _base2.static_dir = this.options.project_path + (this.options.debug && '/build' || '/dist');
    }
    if ((_base3 = this.options).static_url == null) {
      _base3.static_url = '/_static/';
    }
    if ((_base4 = this.options).ssl == null) {
      _base4.ssl = this.ssl_autoconfig();
    }
    if ((_base5 = this.options).port == null) {
      _base5.port = this.options.debug && 3000 || (this.options.ssl && 443 || 80);
    }
    if ((_base6 = this.options).cluster == null) {
      _base6.cluster = !this.options.debug && os.cpus().length || false;
    }
    if ((_base7 = this.options).redirect == null) {
      _base7.redirect = true;
    }
    if ((_base8 = this.options).indexing == null) {
      _base8.indexing = true;
    }
    if (this.options.cluster && cluster.isMaster) {
      for (i = _j = 1, _ref3 = this.options.cluster; 1 <= _ref3 ? _j <= _ref3 : _j >= _ref3; i = 1 <= _ref3 ? ++_j : --_j) {
        cluster.fork();
      }
    } else {
      this.listener = connect();
      this.listener.use((require('connect-slashes'))(false));
      this["static"](this.options.static_url, this.options.static_dir);
      if (this.options.debug) {
        this["static"]('/src', '/src', false);
      }
      if (this.options.ssl) {
        this.server = https.createServer(this.options.ssl, this.listener).listen(this.options.port);
        if (this.options.redirect && this.options.port === 443) {
          this.create_redirect_server(80, 443);
        }
      } else {
        this.server = http.createServer(this.listener).listen(port);
      }
      context = this.app;
      authenticate = function(info, cb) {
        return cb(true);
      };
      this.socket = new SocketServer(this.server, context, authenticate);
      this.listener.use('/favicon.ico', function(req, res) {
        res.writeHead(404);
        return res.end();
      });
      if (this.options.indexing) {
        markup = fs.readFileSync(this.options.static_dir + '/index.html');
        jsdom.env({
          html: markup,
          features: {
            FetchExternalResources: false
          },
          done: function(errors, window) {
            var k, v;
            for (k in window) {
              v = window[k];
              if (typeof global[k] === 'undefined') {
                global[k] = v;
              }
            }
            return _this.listener.use('/', function(req, res) {
              var fn_view, t;
              t = new Date;
              fn_view = _this.app.prototype.dispatch(req.url, true);
              _this.app.prototype.current.once('rendered', function() {
                res.write(window.document.innerHTML);
                res.end();
                return console.log('>>> served ', req.url, ' in ', new Date - t, ' msecs');
              });
              return fn_view();
            });
          }
        });
      } else {
        this.listener.use('/', function(req, res) {
          return send(req, '/index.html').root(_this.options.static_dir).pipe(res);
        });
      }
    }
  }

  Server.prototype["static"] = function(url, dir, live) {
    var expires;
    if (live == null) {
      live = this.options.debug;
    }
    expires = this.options.debug && 0 || (3600 * 24 * 365);
    this.listener.use(url, connect["static"](dir, {
      maxAge: expires
    }));
    if (live) {
      return this.livereload(url, dir);
    }
  };

  Server.prototype.livereload = function(url, dir) {
    var _this = this;
    return watch(path.normalize(dir)).on('change', function(path) {
      return fs.readFile(path, function(err, buf) {
        return _this.socket.broadcast({
          namespace: 'livereload',
          path: url + path.slice(dir.length + 1),
          content: buf.toString()
        });
      });
    });
  };

  Server.prototype.ssl_autoconfig = function() {
    var file_not_found, ssl;
    try {
      ssl = {
        key: fs.readFileSync(this.options.project_path + '/ssl/server.key'),
        cert: fs.readFileSync(this.options.project_path + '/ssl/server.crt')
      };
      return ssl;
    } catch (_error) {
      file_not_found = _error;
      return false;
    }
  };

  Server.prototype.create_redirect_server = function(port_from, port_to) {
    return http.createServer(function(req, res) {
      var secure_host;
      secure_host = req.headers.host.replace(/:[0-9]+/, ":" + port_to);
      res.writeHead(301, {
        Location: 'https://' + secure_host + req.url
      });
      return res.end();
    }).listen(port_from);
  };

  return Server;

})();

exports = module.exports = Server;

/*
//@ sourceMappingURL=server.map
*/
